---
title: Password Encoding with Spring Security
categories: [spring-boot]
date: 2020-02-18 05:00:00 +1100
modified: 2020-02-18 05:00:00 +1100
author: artur
excerpt: "When you have to store user passwords, you have to do securely. Let's have a look how to handle passwords with Spring Security in a Spring Boot application "
image:
  auto: 0060-password
---

Systems with user management require authentication. If we use the password-based authentication,
we have to handle users' passwords in our system. This article shows how to encode and save passwords securely
with Spring Security.


{% include github-project.html url="https://github.com/arkuksin/code-examples/tree/spring-boot-password-emcoding" %}
__Please change the url to github after merging PR for examples and before merging PR for this article__

# Problem with Password Storage on the Server Side
If we want to authenticate the user on the server-side, we have to do the following steps:
1. Get the password from the user, who wants to authenticate,
2. Find the user in the storage, usually a database,
3. Compare the password, which is sent from the user, with the password from the database. 

## Saving Password as Plain Text
We have to deal with the fact, that we have to save users' passwords in our system for comparison by the authentication.
Obviously, it is a bad idea to save passwords as plain text in the database. We should assume,
that the attacker can steal the database with passwords or get access to the passwords by other methods like SQL injections.
In this case, the attacker could use the password right away to access the application. So we need to save the passwords
in such form, that the attacker can't use it for the authentication.
 
## Hashing

 __Hashing solves the problem of the immediate
access to the system with exposed passwords.__

Hashing is a one-way function, that converts the input to a line of symbols. Normally the length of this line is fixed.
If the data is hashed, it is very hard to convert the hash back to the original input and it is very hard to find the
input to get the desired output. We have to hash the password in two cases. First, when the user registers in the application
we hash the password and save it. Second, when the user wants to authenticate, we hash the password and compare it with the password from the database.

Now when attackers get the hash of a password, they are not able to use it for accessing the system. Any try to find the plain text from the hash value requires a huge effort from the attacker. A brute force attack can be very expensive
if the hash is long enough. However, attackers can achieve success using rainbow tables. A rainbow table is a table with
precomputed hashes for many passwords. There is a lot of rainbow tables on the internet and some of them contain millions of
passwords.

## Salt the Password

To prevent the attack with rainbow tables we can use salted passwords. Salt is a sequence of randomly generated bytes,
that are hashed along to password. The salt is stored in the storage and it doesn't need to be protected.
Whenever the user tries to authenticate, the password of the user is hashed with the saved salt and the result should match
the stored password. There is a very small probability, that the combination of the password and the salt is precomputed
in a rainbow table. If the salt is long and random enough, it is impossible to find the hash in a rainbow table.
Since the salt is not a secret, attackers are still able to start a brute force attack.
A salt can make the attack difficult to the attacker, but hardware is getting more efficient.
We must assume fast-evolving hardware. The attacker can start a brute force attack for
a single password and find the original text, because modern hardware can calculate billions of hashes per second.

__Hashing and salting are necessary but not enough.__

## Password Hashing Functions
Hash functions were not created to hash only passwords. The developer of hash function did a very good job
and made the hash function very fast. If we can hash passwords very fast, then the attacker can run the brute force attack
very fast too. The solution is __making password hashing slow__. But how slow can it be? It should be so slow,
that the user can accept that time, but it drives the brute force attack into infinity.
We don't need to develop the slow hashing on our own. There are several algorithms, that are developed especially 
for password hashing. For example:
* bcrypt,
* scrypt,
* PBKDF2,
* argon2
* and others.

They use a complicated cryptographic algorithm and allocate resources like CPU or memory deliberately.


## Work Factor
Work factor is a configuration of the password encodings, that can be increased with growing hardware power.
Every password encoding has its own work factor. Work factor influences the speed of the password encoding.
For instance, `bcrypt` has the parameter `strength`. This is the two to the power of `stregth` and means the number of iteration
using by the algorithm. The bigger the the number is, the slower works the encoding. 

# Password Encoding with Spring Security
Now we can see how Spring Security supports these algorithms and how we can handle passwords with them.

## Password Encoders
First, let's have a look at single password encoders of Spring Security.
All password encoders implement the interface `PasswordEncoder`.
This interface defines methods `enocode()` to convert the plain
password to the encoded form and the method `matches()` to compare the plain password with the encoded password.
Every encoder has a default constructor,
that creates an instance with the default work factor. We can use other constructors for tuning the work factor.


### BCryptPasswordEncoder
```java
 int strength = 10; // work factor of bcrypt
 BCryptPasswordEncoder bCryptPasswordEncoder =
    new BCryptPasswordEncoder(strength, new SecureRandom());
 String encodedPassword = bCryptPasswordEncoder.encode(plainPassword);
```

`BCryptPasswordEncoder` has the parameter `strength`. The default value in Spring Security is 10.
It is recommended to use the `SecureRandom`, because it provides a cryptographically strong random number for a salt generation.
The output looks like
```
$2a$10$EzbrJCN8wj8M8B5aQiRmiuWqVvnxna73Ccvm38aoneiJb88kkwlH2
```

Note, in contrast to simple hash algorithms like SHA-256 or MD5, the output of `bcrypt` contains meta information
about the version of the algorithm, work factor, and salt. We don't need to save this information separately.

### Pbkdf2PasswordEncoder
````java
String pepper = "pepper"; // secret key used by password encoding
int iterations = 200000; // number of hash iteration
int hashWidth = 256; // hash width in bits

Pbkdf2PasswordEncoder pbkdf2PasswordEncoder =
        new Pbkdf2PasswordEncoder(pepper, iterations, hashWidth);
pbkdf2PasswordEncoder.setEncodeHashAsBase64(true);
String encodedPassword = pbkdf2PasswordEncoder.encode(plainPassword);
````  

The PBKDF2 algorithm was not designed for password encoding but the key derivation from a password.
It runs the hash algorithm over the plain password many times. It generates a salt too. We
can define how long the output can be and additionally we can use a secret called `pepper` to
make the password encoding more secure.

The output looks like

```
lLDINGz0YLUUFQuuj5ChAsq0GNM9yHeUAJiL2Be7WUh43Xo3gmXNaw==
```

The salt is saved within, but we have to save the iteration number and hash width additionally. The `pepper`
should be kept as a secret.
The default value of the iteration number is 185000 and the hash width is 256

### SCryptPasswordEncoder
```java
int cpuCost = (int) Math.pow(2, 14); // factor to increase CPU costs
int memoryCost = 8; // factor to increases memory usage
int parallelization = 1; // currently  nor supported by Spring Security
int keyLength = 32; // key length in bytes
int saltLength = 64; // salt length in bytes

SCryptPasswordEncoder sCryptPasswordEncoder =
        new SCryptPasswordEncoder(cpuCost, memoryCost, parallelization, keyLength, saltLength);
String encodedPassword = sCryptPasswordEncoder.encode(plainPassword);
```

The `scrypt` algorithm can not only configure the CPU cost but memory cost. It makes the attack very expensive.
For example with the parameter from the code above, the password encoding will require 16MB memory.   
The output looks like
````
$e0801$jRlFuIUd6eAZcuM1wKrzswD8TeKPed9wuWf3lwsWkStxHs0DvdpOZQB32cQJnf0lq/dxL+QsbDpSyyc9Pnet1A==$P3imAo3G8k27RccgP5iR/uoP8FgWGSS920YnHj+CRVA=
````
This encoder puts the parameter for work factor and salt in the result string, so there is no additional information to save.

### Argon2PasswordEncoder
```java
int saltLength = 16; // salt length in bytes
int hashLength = 32; // hash length in bytes
int parallelism = 1; // currently it is not supported
int memory = 4096; // memory costs
int iterations = 3;

Argon2PasswordEncoder argon2PasswordEncoder =
        new Argon2PasswordEncoder(saltLength, hashLength, parallelism, memory, iterations);
String encodePassword = argon2PasswordEncoder.encode(plainPassword);
````
Argon2 is the winner of Password Hashing Competition in 2015. Also, this algorithm can be tuned for using CPU and memory
costs. Argon2 encoder saves all the parameters in the result string. If we want to use this password encoder,
we have to import `BouncyCastle`. 

## Password Encoders in a Spring Boot Application
To see how it works with Spring Boot let's create an application with REST APIs and password based authentication
supported by Spring Security. The passwords are stored in the relational database. To keep it simple in this example
we send the user credentials with every HTTP request. It means the application must start authentication whenever the client wants to access the API.

First, we create an API, which should be protected by Spring Security
```java
@RestController
public class CarResources {

   @GetMapping("/cars")
       public Set<Car> cars() {
           return Set.of(
                   new Car("vw", "black"),
                   new Car("bmw", "white"));
       }
}
```
Our goal is to provide access to resource `/cars` for authenticated users only.
Now we create a `Configuration` with Spring Security rules.
````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
        protected void configure(HttpSecurity httpSecurity) throws Exception {
            httpSecurity
                    .csrf()
                    .disable()
                    .authorizeRequests()
                    .antMatchers("/registration")
                    .permitAll()
                    .anyRequest()
                    .authenticated()
                    .and()
                    .httpBasic();
        }
}
````
This code create rules, that require the authentication for all endpoints except `/registration`
and enables the HTTP basic authentication. Every time, when an HTTP request is sent to the application,
Spring Security checks, if the header contains `Authorization: Basic <credentials>`.
If the header is not set, the server sends response 401 (Unauthorized) to the client. If the header is found
Spring Security starts the authentication. To do this, Spring Security needs user data with user names and
passwords. That's why we have to implement `UserDetailsService` interface. This interface loads user-specific data and
needs read-only access to user data.

```java
@Service
public class JdbcUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;
    private final UserDetailsMapper userDetailsMapper;

    public JdbcUserDetailsService(
            UserRepository userRepository, UserDetailsMapper userDetailsMapper) {
        this.userRepository = userRepository;
        this.userDetailsMapper = userDetailsMapper;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserCredentials userCredentials = userRepository.findByUsername(username);
        return userDetailsMapper.toUserDetails(userCredentials);
    }
}
```
In the service we implement the method `loadUserByUsername()`, that loads user data from the database.
The `UserDetailsService` is used by an `AuthenticationProvider` interface. This interface defines the actual authentication logic. 
There are many implementations of this interface, but we are interested in `DaoAuthenticationProvider`,
because we store the data in the database. 
````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
     
     private final JdbcUserDetailsService jdbcUserDetailsService;
    
     public SecurityConfiguration(JdbcUserDetailsService jdbcUserDetailsService) {
        this.jdbcUserDetailsService = jdbcUserDetailsService;
     }
     

     @Autowired
     public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(daoAuthenticationProvider());
     }
    
     public AuthenticationProvider daoAuthenticationProvider() {
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
        daoAuthenticationProvider.setUserDetailsService(this.jdbcUserDetailsService);
        return daoAuthenticationProvider;
     }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
       return new BCryptPasswordEncoder();
    }
}
````
We created a `DaoAuthenticationProvider` and set the password encoder `BCryptPasswordEncoder` to the authentication provider.
That's it for the password encoding. This `BCryptPasswordEncoder` will be automatically used by `AuthenticationProvider`
for password encoding and password matching. Now we have to make one step more to complete the configuration. We 
set the `JdbcUserDetailsService` service to the `DaoAuthenticationProvider`. After that `DaoAuthenticationProvider` can 
get the user data to execute the authentication. Spring Security takes care of the rest. If a client sends a 
HTTP request with basic authentication header, Spring Security will read this header, load data for the user,
who wants to authenticate and matches the password using `BCryptPasswordEncoder`. If the password matches the request will be passed
through, if not the server will send a response with status code 401.

To add a user to the system, let's implement the API for registration.
````java
@RestController
@Transactional
public class UserResources {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserResources(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @PostMapping("/registration")
    @ResponseStatus(code = HttpStatus.CREATED)
    public void register(@RequestBody UserCredentialsDto userCredentialsDto) {
        UserCredentials user =
                UserCredentials.builder()
                        .enabled(true)
                        .username(userCredentialsDto.getUsername())
                        .password(passwordEncoder.encode(userCredentialsDto.getPassword()))
                        .roles(Set.of("USER"))
                        .build();
        userRepository.save(user);
    }
}
```` 
As we defined in Spring Security rules, the access to `/regestration` API is open for everybody. We use the `PasswordEncoder`, that is defined in
Spring Security configuration to encode the password. In this example, the passwords are encoded with `bcrypt` algorithm. 
The code just saves the new user to the database. After that, the user is ready to authenticate.

## Upgrade Work Factor of Encoding
There are cases where we should increase the work factor of encoding for an existing application, that
uses `PasswordEncoder`.
Maybe, the work factor set years ago is not strong enough for today. Also maybe,
the work factor we use today will not be secure in a couple of years. In this case, we __should__ increase the work factor
of password encoding. The application can get better hardware, where it is running on. In this case, we __can__
increase work factors without significantly increasing authentication time. Spring Security supports the update of the 
work factor for many encoding algorithms.
To achieve this, we have to do two things. First, to implement `UserDetailsPasswordService` interface.
````java
@Service
@Transational
public class JdbcUserDetailPasswordService implements UserDetailsPasswordService {

    private final UserRepository userRepository;

    private final UserDetailsMapper userDetailsMapper;

    public JdbcUserDetailPasswordService(
            UserRepository userRepository, UserDetailsMapper userDetailsMapper) {
        this.userRepository = userRepository;
        this.userDetailsMapper = userDetailsMapper;
    }

    @Override
    public UserDetails updatePassword(UserDetails user, String newPassword) {
        UserCredentials userCredentials = userRepository.findByUsername(user.getUsername());
        userCredentials.setPassword(newPassword);
        return userDetailsMapper.toUserDetails(userCredentials);
    }
}
````
In the method `updatePassword()` we just set the new password to the user in the database.
Second, we make this interface known to `AuthenticationProvider`
````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
     
     private final JdbcUserDetailPasswordService jdbcUserDetailPasswordService;
     
     public SecurityConfiguration(JdbcUserDetailPasswordService jdbcUserDetailPasswordService) {
        this.jdbcUserDetailPasswordService = jdbcUserDetailPasswordService;
    }


     public AuthenticationProvider daoAuthenticationProvider() {
       DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
       daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
       daoAuthenticationProvider.setUserDetailsPasswordService(this.jdbcUserDetailPasswordService);
       daoAuthenticationProvider.setUserDetailsService(this.jdbcUserDetailsService);
       return daoAuthenticationProvider;
     }
}
````
That's it. Now, whenever a user starts the authentication, Spring Security compares the work factor in the encoded password
of the user with the current work factor of `PasswordEncoder`. If the current work factor is stronger, the authentication
provider will encode the password of the user with the current password encoder and update it using `JdbcUserDetailPasswordService`
automatically.

For example, if passwords are currently encoded with `BCryptPasswordEncoder` of strength 5, we can just add a password encoder
of strength 10
```java
    @Bean
    public PasswordEncoder passwordEncoder() {
       return new BCryptPasswordEncoder(10);
    }
```
After that, the passwords are migrated from strength 5 to 10 gradually.


## Support of Multiple Password Encoding in One Application
Some application lives very long. So long, that the standards and best practices for password encoding change. Image
we support an application with thousands of users and this application uses a normal SHA-1 hashing for password encoding.
It means all passwords are stored in the database as SHA-1 hashes. Now we want to be security conform and use for example 
`scrypt`. We can do it at least for all new users because the Spring Security supports the multiple password encoding.
To be able to encode and to match passwords, that are encoded by different algorithms in one application, we can use
`DelegatingPasswordEncoder`. This encoder delegates the encoding to another encoder using prefixes.
````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
````
The simplest way is to let to generate the `DelegatingPasswordEncoder` by `PasswordEncoderFactories` factory. 
This factory generates a `DelegatingPasswordEncoder`, that supports __all encoders of Spring Security for matching__.
`DelegatingPasswordEncoder` has __one default encoder__. The `PasswordEncoderFactories` set
`BCryptPasswordEncoder` as default encoder. Now when a user is saved while registration,
the password encoder will encode the password and add a prefix at the beginning
of the result string. The encoded password looks like
```
{bcrypt}$2a$10$4V9kA793Pi2xf94dYFgKWuw8ukyETxWb7tZ4/mfco9sWkwvBQndxW
```

When the user with this password wants to authenticate the `DelegatingPasswordEncoder` can recognize the prefix und choose
the suitable encoder for matching. In the example with the old SHA-1 passwords, we have to run a SQL-script, that put a `{SHA-1}`
prefix in every password. From this moment, `DelegatingPasswordEncoder` can match the `SHA-1` password, when the user wants to authenticate.
But we don't want to use `BCryptPasswordEncoder` as default encoder. We want to encode the password for new users with `SCryptPasswordEncoder`.
We can set the default password encoder after creating `DelegatingPasswordEncoder`.

````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Bean
    public PasswordEncoder passwordEncoder() {
        DelegatingPasswordEncoder delegatingPasswordEncoder = 
            (DelegatingPasswordEncoder) PasswordEncoderFactories.createDelegatingPasswordEncoder();
        delegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(new SCryptPasswordEncoder());
        return delegatingPasswordEncoder;
    }
}
````

We can decide, what encoders should be supported if we create a `DelegatingPasswordEncoder` on our own.

````java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Bean
    public PasswordEncoder passwordEncoder() {
        String encodingId = "scrypt";
        Map<String, PasswordEncoder> encoders = new HashMap<>();
        encoders.put(encodingId, new SCryptPasswordEncoder());
        encoders.put("SHA-1", new MessageDigestPasswordEncoder("SHA-1"));
        return new DelegatingPasswordEncoder(encodingId, encoders);
    }
}
````
This code creates a password encoder, that supports `SHA-1` and `scrypt` for matching and uses `scrypt` 
for encoding passwords. Now we have users in the database with both password encodings `SHA-1` and `scrypt` 
and the application supports both encodings.


## Migrate Encoding
If the passwords in the database are encoded by an old algorithm, then it would be better to
migrate the passwords to another encoding. To migrate a password to another encoding we have to encode the plain text
password. Of course, we don't have this in the database and we can't compute it without huge effort.
Also, we can't force the users to migrate their passwords. By we can implement a
slow gradual migration. Every time, when the user authenticates, we encode the plain password, that the user sends
to the server and override the old one in the database. This approach is transparent to the users.
First, we have to set `eraseCredentials` property to false in security configuration, because the Spring Security removes
the credentials from the memory as soon as possible.  

````java
    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(daoAuthenticationProvider())
                .eraseCredentials(false);
    }
````

Now we can implement `ApplicationListener` for `AuthenticationSuccessEvent`.
````java
@Component
public class PasswordMigration {

    @Bean
    public ApplicationListener<AuthenticationSuccessEvent> authenticationSuccessListener(
            PasswordEncoder encoder, UserDetailsPasswordService userDetailsPasswordService) {
        return (AuthenticationSuccessEvent event) -> {
            Authentication authentication = event.getAuthentication();
            User user = (User) authentication.getPrincipal();
            String encodedPassword = user.getPassword();
            if (encodedPassword.startsWith("{SHA-1}")) {
                CharSequence clearTextPassword = (CharSequence) authentication.getCredentials();
                String newPassword = encoder.encode(clearTextPassword);
                userDetailsPasswordService.updatePassword(user, newPassword);
            }
            ((UsernamePasswordAuthenticationToken) authentication).eraseCredentials();
        };
    }
}
````

This method is called every time when the authentication was successful. For the password update we user the 
`UserDetailsPasswordService` we implemented before. Note, that at the end of the code we erase the credentials
of the user.

## Calculation of the Optimal Work Factor
How to choose the suitable work factor for the password encoder? The Spring Security recommends tuning the
password encoder to take about 1 second to verify the password. But this time depends on hardware, where the application runs.
If the same application runs on different hardware by different customers, we can not set the best work factor to compile time.
But we can calculate the good work factor by starting the application.

````java
 @Bean
    public PasswordEncoder passwordEncoder() {
       return new BCryptPasswordEncoder(bcCryptWorkFactorService.calculateStrength());
    }
````   

The method `calculateStrength()` returns the work factor, that is needed to encode the password so that it takes about 1
second. The method is executed by starting the application on the current hardware. If the application starts by different customers,
the best work factor will be found automatically. Note, that this method can take several seconds. It means the start of the application
is slower than usual. 

# Conclusion
Spring Security supports many password encoders, both old and modern algorithms. Also, Spring Security
provides methods to work with multiple password encoding in one application. If we need we can
change the work factor of password encodings or migrate from one encoding to another without affecting users.
 


  



 
 

